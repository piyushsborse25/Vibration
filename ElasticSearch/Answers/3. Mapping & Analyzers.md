---

## **3. Mapping & Analyzers (Q11–Q15)**

---

**11. What’s the difference between dynamic mapping and explicit mapping?**

- **Answer:**
    
    - **Dynamic mapping:** ES automatically detects field types based on first inserted value.
        
    - **Explicit mapping:** You define field names, types, analyzers manually before indexing.
        
- **Pitfall Note:** Dynamic mapping can misinterpret types (e.g., `00123` → `integer`, losing leading zeros).
    

---

**12. What happens if you index a field with inconsistent data types across documents?**

- **Answer:**
    
    - ES uses the mapping from the first occurrence; later mismatched types cause `mapper_parsing_exception`.
        
- **Pitfall Note:** This is a common bug when logs contain varying formats for the same field name.
    

---

**13. Difference between `keyword` and `text` data types.**

- **Answer:**
    
    - **`text`:** Analyzed, tokenized, used for full-text search; no exact match guarantee.
        
    - **`keyword`:** Not analyzed, stored as-is, good for filtering, sorting, and aggregations.
        
- **Pitfall Note:** Using `text` for sorting will throw an error unless you enable `fielddata` (bad for memory).
    

---

**14. Can you change the type of an existing field in Elasticsearch? If not, why?**

- **Answer:**
    
    - No, because field type determines how values are stored in the inverted index — changing it would require reindexing.
        
- **Pitfall Note:** The only workaround is creating a new index with updated mapping and reindexing the data.
    

---

**15. How does a custom analyzer differ from the built-in ones?**

- **Answer:**
    
    - A **custom analyzer** lets you define character filters, tokenizer, and token filters in a specific order.
        
    - Built-in analyzers (e.g., `standard`, `simple`) have predefined configurations.
        
- **Pitfall Note:** If you forget to reindex after creating a custom analyzer, old data won’t be affected — only new documents will use it.
    

---