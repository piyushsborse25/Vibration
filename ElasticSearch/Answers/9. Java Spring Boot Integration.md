# **Java / Spring Boot Integration (Q41–Q45)**

**41. How does Spring Data Elasticsearch differ from using the Elasticsearch REST API directly?**

- **Answer:** Spring Data ES offers repository abstractions, entity → document mapping, paging/sorting, query method derivation, and integration with Spring lifecycle. The REST API (or low-level client) gives full control over the Query DSL, latest ES features, and finer-grained tuning.
    
- **Pitfall:** Spring Data can lag behind ES features/versions and sometimes hides behavior (auto-mapping, conversions). For cutting-edge features or performance tuning prefer direct REST/clients.
    

**42. What’s the difference between Native Query and Criteria Query in Spring Data Elasticsearch?**

- **Answer:** _NativeQuery_ (or native `NativeSearchQuery`) is building raw ES Query DSL (JSON/QueryBuilder) — full power and flexibility. _CriteriaQuery_ is a higher-level type-safe builder from Spring Data for common queries (easier, but less expressive).
    
- **Pitfall:** Criteria may not support advanced constructs (nested aggregations, complex scripting); use native queries for advanced search logic.
    

**43. How would you implement autocomplete using Elasticsearch and Spring Boot?**

- **Answer (approaches):**
    
    1. **Completion suggester** (`completion` field) — fastest for prefix suggestions, supports payloads.
        
    2. **edge_ngram / ngram** analyzer on a `text` field (or `search_as_you_type` field type) — flexible and supports fuzzy/prefix scoring.
        
    3. Use a dedicated index of suggestion documents with popularity boosting.  
        In Spring Boot: configure mapping (completion or ngram), index suggestion data, query using `SuggestBuilder` or native JSON from your service/repository.
        
- **Pitfall:** `completion` is memory-heavy; n-grams increase index size and complexity; be careful with tokenization (case, diacritics) and freshness (update strategy for suggestions).
    

**44. How do you test Elasticsearch integration in Java using Testcontainers?**

- **Answer:** Use Testcontainers’ Elasticsearch container in integration tests (JUnit). Start container with `@Container`, configure your ES client (RestClient/RestHighLevelClient or Spring Test config) to point to container URI, apply index mappings & seed test data, run tests, then teardown. Optionally reuse container across tests to speed up.
    
- **Pitfall:** ES containers are resource-heavy and slower; ensure client/container versions match; network/resource limits can flake tests — prefer a dedicated CI runner with enough memory or reuse a shared test container.
    

**45. How do you handle Elasticsearch version upgrades in Spring Boot projects?**

- **Answer:** Read ES release notes, update Java client & Spring Data ES to compatible versions, test in a staging cluster (rolling upgrade if cluster), run integration tests and migration scripts, reindex if mapping/format changes, and backup snapshots before upgrade.
    
- **Pitfall:** Mixed-version clusters have limits (only certain version gaps allowed); Spring Data may not support new ES features immediately — consider using low-level REST client for compatibility.