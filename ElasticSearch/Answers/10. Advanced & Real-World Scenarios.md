# **Advanced & Real-World Scenarios (Q46–Q50)**

**46. How do you use the Reindex API, and what are its pitfalls?**

- **Answer:** Reindex copies documents from a source index (or remote) to a destination index, supports scripts and pipelines for transformations, and can be parallelized with `slices`. Common use-cases: change mapping, shard count, or transform docs.
    
- **Pitfall:** High I/O and cluster load; version conflicts if source updated during reindex; does **not** copy index settings/aliases/analyzers — you must recreate them on destination; consider throttling and using snapshots for safety.
    

**47. What’s the difference between nested objects and parent-child relationships in Elasticsearch?**

- **Answer:**
    
    - **Nested**: `nested` type stores each object in the array as separate hidden docs but keeps them within the same root document — queries preserve object boundaries (no cross-object mixing). Good when you always fetch/update as one unit.
        
    - **Parent-child**: Separate documents with a `join` field; child docs stored separately and linked to parent — useful when many child docs per parent or you frequently update children without reindexing parent.
        
- **Pitfall:** Nested docs are part of parent (cannot update independently); parent-child requires routing and can be slower/complex; both have performance trade-offs — choose based on update patterns and query needs.
    

**48. How do you implement a geo-spatial query for “restaurants near me”?**

- **Answer:** Map location as `geo_point`. Use `geo_distance` query to filter by distance and `_geo_distance` sort to order by proximity. Optionally use `geo_bounding_box` (fast pre-filter) or `geo_polygon`. In Spring use `GeoDistanceQueryBuilder` or native JSON.
    
- **Pitfall:** Use appropriate units (km/m), pre-filter with bounding box for performance, handle pagination with `search_after` when sorting by distance, and ensure consistent coordinate format and precision.
    

**49. How would you design an Elasticsearch cluster for multi-tenant applications?**

- **Answer (options):**
    
    - **Single index + tenant field + routing:** Good for many tenants, use routing to pin tenant docs to specific shards.
        
    - **Index per tenant:** Strong isolation, easy retention per tenant — but not for thousands of tenants (cluster state bloat).
        
    - **Hybrid:** Group tenants into indices (tenant buckets) based on size. Use aliases, templates, and index lifecycle policies. Enforce RBAC and quotas.
        
- **Pitfall:** Too many small indices/shards causes cluster-state and memory issues; routing can unbalance shards if tenant sizes vary; per-tenant security/isolation may require separate clusters.
    

**50. What’s the difference between Elasticsearch and OpenSearch, and why might you choose one over the other?**

- **Answer:** OpenSearch is a community/AWS-led fork of Elasticsearch/Kibana after Elastic’s license change. Differences include licensing (OpenSearch is Apache 2.0), divergent feature sets and roadmaps over time, and differing vendor ecosystems. Choose **OpenSearch** for open-license, AWS-managed support, or community focus; choose **Elasticsearch** for Elastic’s commercial features, official support, and certain enterprise plugins.
    
- **Pitfall:** APIs and plugins diverge over time — check compatibility before migrating; license/policy may influence corporate choices.