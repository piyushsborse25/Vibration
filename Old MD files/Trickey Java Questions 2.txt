List of tricky Java Core questions designed to challenge and explore deeper understanding of Java concepts:

---

1. Object-Oriented Programming
1. What happens if a subclass has a method with the same name as a private method in the superclass? Is this considered overriding?
2. Can you declare an abstract class without any abstract methods? Why would you do that?
3. How does Java achieve runtime polymorphism? Can method overloading achieve the same?
4. If a class implements two interfaces with the same default method, how does Java resolve the conflict?

---

2. Exception Handling
1. Can a `try` block exist without a `catch` block? What is the purpose of such a construct?
2. Can you catch multiple exceptions in a single `catch` block? How is this implemented in Java?
3. What happens if an exception is thrown in a constructor? Will the object still be partially constructed?
4. Explain how exception chaining works in Java. Why would you use it?
5. Is it possible to have multiple `finally` blocks in a `try` statement?

---

3. Multithreading and Concurrency
1. How does the Java Memory Model (JMM) ensure visibility and ordering of shared variables in a multi-threaded environment?
2. What are the differences between `synchronized` and `Lock` from `java.util.concurrent.locks`?
3. Explain the difference between `Thread.yield()`, `Thread.sleep()`, and `Thread.join()`.
4. What happens if a thread calls `wait()` on an object without holding the lock?
5. Can `volatile` variables guarantee thread safety for increment operations? Why or why not?

---

4. JVM Internals
1. What is the role of the `permgen` space in JVM (pre-Java 8) vs. `Metaspace` (Java 8+)? Why was this change introduced?
2. How does the JVM handle method overloading and overriding at runtime?
3. Explain how the `invokedynamic` instruction works in the JVM. How does it improve performance?
4. What is an escape analysis in JVM, and how does it optimize memory allocation?
5. What is the significance of the `-XX:+UseG1GC` JVM option? When would you use it?

---

5. Strings and String Pool
1. How does the String pool in Java work? Can you disable it?
2. What happens if you use `String.intern()` on a dynamically created string?
3. Why is `String` immutable, but `StringBuilder` and `StringBuffer` are not? Can you make `StringBuilder` immutable?
4. What are the memory implications of using `String` concatenation with the `+` operator in a loop?
5. How does `String` deduplication work in Java 9+?

---

6. Java Collections
1. How does `LinkedHashSet` maintain insertion order? How does it handle hash collisions?
2. Explain the significance of the `load factor` in `HashMap`. How does it impact performance?
3. Can you store `null` as a key in `TreeMap`? Why or why not?
4. What happens when you modify an object that is used as a key in a `HashMap`? How can this lead to unexpected behavior?
5. What is the difference between `ConcurrentSkipListMap` and `TreeMap`?

---

7. Serialization
1. How can you exclude certain fields from being serialized? What is the purpose of the `transient` keyword?
2. What happens if a serialized class changes its structure (e.g., adds or removes fields)? How can you maintain compatibility?
3. Can you serialize a static field? Why or why not?
4. What is the role of the `writeReplace()` and `readResolve()` methods in serialization?
5. Explain how custom serialization works using the `Externalizable` interface.

---

8. Advanced Java Keywords
1. What happens if you declare a variable as `final` but do not initialize it immediately?
2. Can a `final` method be overloaded? If yes, how?
3. What is the difference between `transient` and `volatile`? Can they be used together?
4. Why can't a `static` method be abstract in Java?
5. Explain the purpose of the `native` keyword. Provide a scenario where it is used.

---

9. Class Loaders
1. How does the parent delegation model work in Java class loading? Can it be overridden?
2. What is the difference between `bootstrap`, `extension`, and `application` class loaders?
3. How would you use a custom class loader to load classes at runtime?
4. What happens if two different class loaders load the same class? Are the objects compatible?
5. Can you dynamically reload a class in Java? How can you achieve this?

---

10. Annotations
1. What is the difference between a marker annotation and a regular annotation? Provide examples.
2. How does Java handle runtime retention for annotations? What is the significance of `@Retention(RUNTIME)`?
3. Can annotations have default values? If so, how are they defined and used?
4. What is a meta-annotation in Java? Provide examples of commonly used meta-annotations.
5. How would you process custom annotations at runtime? Explain with an example.

---

11. Reflection
1. Can you use reflection to access private fields and methods in Java? How does it work?
2. What is the difference between `Class.forName()` and `ClassLoader.loadClass()`?
3. How does reflection affect performance? When should you avoid using it?
4. What are the security implications of using reflection in Java?
5. How do you create objects dynamically using reflection?

---

12. Miscellaneous
1. Explain the difference between `System.gc()` and `Runtime.getRuntime().gc()`. Does calling them guarantee garbage collection?
2. Why are wrapper classes (`Integer`, `Double`, etc.) immutable in Java? How does autoboxing affect this?
3. What is the difference between `pass by value` and `pass by reference`? Is Java truly "pass by value"?
4. Can you force the JVM to execute code after a `System.exit()` call? If yes, how?
5. What is a daemon thread? How does it differ from a user thread?

---

Bonus Tricky Question
Q: What is the difference between `Object`'s `wait()` method and `Thread.sleep()`?  
-Answer:
  - `wait()` releases the lock held by the current thread and waits until another thread calls `notify()` or `notifyAll()`. It must be called within a `synchronized` block.
  - `sleep()` pauses the current thread for a specified period but does not release the lock. It is not dependent on synchronization.

---